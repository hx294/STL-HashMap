!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Sh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Sh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Sh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Sh	s,script	/script files/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PARSER_VERSION!Sh	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/hx/courses/cs106l-assiments/HashMap_Starter/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	/p6.0.20231001.0/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Sh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Sh!script	loaded	/loaded/
A_basic	tests.cpp	/^void A_basic() {$/;"	f	typeref:typename:void
A_benchmark_insert_erase	tests.cpp	/^int A_benchmark_insert_erase() {$/;"	f	typeref:typename:int
A_copy_ctor_basic	tests.cpp	/^void A_copy_ctor_basic() {$/;"	f	typeref:typename:void
A_index_operator	tests.cpp	/^void A_index_operator() {$/;"	f	typeref:typename:void
A_range_ctor_basic	tests.cpp	/^void A_range_ctor_basic() {$/;"	f	typeref:typename:void
B_benchmark_find	tests.cpp	/^int B_benchmark_find() {$/;"	f	typeref:typename:int
B_copy_assign_basic	tests.cpp	/^void B_copy_assign_basic() {$/;"	f	typeref:typename:void
B_index_const_correct	tests.cpp	/^void B_index_const_correct() {$/;"	f	typeref:typename:void
B_insert	tests.cpp	/^void B_insert() {$/;"	f	typeref:typename:void
B_range_ctor_edge	tests.cpp	/^void B_range_ctor_edge() {$/;"	f	typeref:typename:void
C_benchmark_iterate	tests.cpp	/^int C_benchmark_iterate() {$/;"	f	typeref:typename:int
C_clear	tests.cpp	/^void C_clear() {$/;"	f	typeref:typename:void
C_copy_edge	tests.cpp	/^void C_copy_edge() {$/;"	f	typeref:typename:void
C_initializer_list_ctor_basic	tests.cpp	/^void C_initializer_list_ctor_basic() {$/;"	f	typeref:typename:void
C_stream_insert_operator	tests.cpp	/^void C_stream_insert_operator() {$/;"	f	typeref:typename:void
D_at	tests.cpp	/^void D_at() {$/;"	f	typeref:typename:void
D_initializer_list_ctor_edge	tests.cpp	/^void D_initializer_list_ctor_edge() {$/;"	f	typeref:typename:void
D_move_ctor_basic	tests.cpp	/^void D_move_ctor_basic() {$/;"	f	typeref:typename:void
D_stream_insert_const_correct	tests.cpp	/^void D_stream_insert_const_correct() {$/;"	f	typeref:typename:void
E_at_const_correct	tests.cpp	/^void E_at_const_correct() {$/;"	f	typeref:typename:void
E_equality_operator	tests.cpp	/^void E_equality_operator() {$/;"	f	typeref:typename:void
E_move_assign_basic	tests.cpp	/^void E_move_assign_basic() {$/;"	f	typeref:typename:void
F_custom_bucket_count	tests.cpp	/^void F_custom_bucket_count() {$/;"	f	typeref:typename:void
F_equality_const_correct	tests.cpp	/^void F_equality_const_correct() {$/;"	f	typeref:typename:void
F_move_edge	tests.cpp	/^void F_move_edge() {$/;"	f	typeref:typename:void
G_custom_hash_function	tests.cpp	/^void G_custom_hash_function() {$/;"	f	typeref:typename:void
G_move_ctor_time	tests.cpp	/^void G_move_ctor_time() {$/;"	f	typeref:typename:void
HASHMAPITERATOR_H	hashmap_iterator.h	/^#define HASHMAPITERATOR_H$/;"	d
HASHMAP_H	hashmap.h	/^#define HASHMAP_H$/;"	d
H_erase	tests.cpp	/^void H_erase() {$/;"	f	typeref:typename:void
H_move_assign_time	tests.cpp	/^void H_move_assign_time() {$/;"	f	typeref:typename:void
HashMap	hashmap.cpp	/^HashMap<K, M, H>::HashMap() : $/;"	f	class:HashMap
HashMap	hashmap.cpp	/^HashMap<K, M, H>::HashMap(InputIt first, InputIt last, size_t bucket_count, const H& hash) :$/;"	f	class:HashMap
HashMap	hashmap.cpp	/^HashMap<K, M, H>::HashMap(size_t bucket_count, const H& hash) :$/;"	f	class:HashMap
HashMap	hashmap.cpp	/^HashMap<K, M, H>::HashMap(std::initializer_list<value_type> init, size_t bucket_count, const H& /;"	f	class:HashMap
HashMap	hashmap.h	/^class HashMap {$/;"	c
HashMapIterator	hashmap_iterator.h	/^HashMapIterator<Map, IsConst>::HashMapIterator(bucket_array_type* buckets_array, node* node,$/;"	f	class:HashMapIterator
HashMapIterator	hashmap_iterator.h	/^class HashMapIterator {$/;"	c
I_rehash_basic	tests.cpp	/^void I_rehash_basic() {$/;"	f	typeref:typename:void
J_iter_foreach_one_bucket	tests.cpp	/^void J_iter_foreach_one_bucket() {$/;"	f	typeref:typename:void
K	tests.cpp	/^    using K = int;$/;"	t	function:G_custom_hash_function	typeref:typename:int	file:
K	tests.cpp	/^    using K = int;$/;"	t	function:unused_rehash_correct_by_time	typeref:typename:int	file:
K_iter_foreach_filled_buckets	tests.cpp	/^void K_iter_foreach_filled_buckets() {$/;"	f	typeref:typename:void
L_iter_foreach_split_buckets	tests.cpp	/^void L_iter_foreach_split_buckets() {$/;"	f	typeref:typename:void
M_iter_foreach_edge	tests.cpp	/^void M_iter_foreach_edge() {$/;"	f	typeref:typename:void
N_iter_forward_operators	tests.cpp	/^void N_iter_forward_operators() {$/;"	f	typeref:typename:void
O_iter_algorithm_copy	tests.cpp	/^void O_iter_algorithm_copy() {$/;"	f	typeref:typename:void
P_iter_algorithm_permutation	tests.cpp	/^void P_iter_algorithm_permutation() {$/;"	f	typeref:typename:void
Q_iter_const_iterator	tests.cpp	/^void Q_iter_const_iterator() {$/;"	f	typeref:typename:void
RUN_BENCHMARK	test_settings.cpp	/^#define RUN_BENCHMARK /;"	d	file:
RUN_TEST_2A	test_settings.cpp	/^#define RUN_TEST_2A /;"	d	file:
RUN_TEST_2B	test_settings.cpp	/^#define RUN_TEST_2B /;"	d	file:
RUN_TEST_2C	test_settings.cpp	/^#define RUN_TEST_2C /;"	d	file:
RUN_TEST_2D	test_settings.cpp	/^#define RUN_TEST_2D /;"	d	file:
RUN_TEST_3A	test_settings.cpp	/^#define RUN_TEST_3A /;"	d	file:
RUN_TEST_3B	test_settings.cpp	/^#define RUN_TEST_3B /;"	d	file:
RUN_TEST_3C	test_settings.cpp	/^#define RUN_TEST_3C /;"	d	file:
RUN_TEST_3D	test_settings.cpp	/^#define RUN_TEST_3D /;"	d	file:
RUN_TEST_3E	test_settings.cpp	/^#define RUN_TEST_3E /;"	d	file:
RUN_TEST_3F	test_settings.cpp	/^#define RUN_TEST_3F /;"	d	file:
RUN_TEST_4A	test_settings.cpp	/^#define RUN_TEST_4A /;"	d	file:
RUN_TEST_4B	test_settings.cpp	/^#define RUN_TEST_4B /;"	d	file:
RUN_TEST_4C	test_settings.cpp	/^#define RUN_TEST_4C /;"	d	file:
RUN_TEST_4D	test_settings.cpp	/^#define RUN_TEST_4D /;"	d	file:
RUN_TEST_4E	test_settings.cpp	/^#define RUN_TEST_4E /;"	d	file:
RUN_TEST_4F	test_settings.cpp	/^#define RUN_TEST_4F /;"	d	file:
RUN_TEST_4G	test_settings.cpp	/^#define RUN_TEST_4G /;"	d	file:
RUN_TEST_4H	test_settings.cpp	/^#define RUN_TEST_4H /;"	d	file:
RUN_TEST_HARNESS	test_settings.cpp	/^#define RUN_TEST_HARNESS /;"	d	file:
R_iter_const_correct	tests.cpp	/^void R_iter_const_correct() {$/;"	f	typeref:typename:void
S_iter_const_conversion	tests.cpp	/^void S_iter_const_conversion() {$/;"	f	typeref:typename:void
T_iter_find_member	tests.cpp	/^void T_iter_find_member() {$/;"	f	typeref:typename:void
U_iter_insert_member	tests.cpp	/^void U_iter_insert_member() {$/;"	f	typeref:typename:void
V	tests.cpp	/^    using V = char;$/;"	t	function:G_custom_hash_function	typeref:typename:char	file:
V	tests.cpp	/^    using V = int;$/;"	t	function:unused_rehash_correct_by_time	typeref:typename:int	file:
VERIFY_TRUE	tests.cpp	/^void VERIFY_TRUE(bool condition, int line) {$/;"	f	typeref:typename:void
V_iter_erase_member	tests.cpp	/^void V_iter_erase_member() {$/;"	f	typeref:typename:void
VerifyTrueAssertionFailure	tests.cpp	/^struct VerifyTrueAssertionFailure {$/;"	s	file:
__anon9bb45ee90102	tests.cpp	/^    auto identity_shifted = [](const K& key) {$/;"	f	function:G_custom_hash_function	file:
__anon9bb45ee90202	tests.cpp	/^    auto identity = [](const K& key) { return key; };$/;"	f	function:unused_rehash_correct_by_time	file:
__anon9bb45ee90302	tests.cpp	/^    auto identity = [](auto i) {return i;};$/;"	f	function:K_iter_foreach_filled_buckets	file:
__anon9bb45ee90402	tests.cpp	/^    auto identity = [](auto i) {return i;};$/;"	f	function:L_iter_foreach_split_buckets	file:
__anon9bb45ee90502	tests.cpp	/^    auto identity_shifted = [](const int& key) {$/;"	f	function:P_iter_algorithm_permutation	file:
__anon9bb45ee90602	tests.cpp	/^    auto good_hash_function = [](const int& key) {$/;"	f	function:A_benchmark_insert_erase	file:
__anon9bb45ee90702	tests.cpp	/^    auto good_hash_function = [](const int& key) {$/;"	f	function:B_benchmark_find	file:
__anon9bb45ee90802	tests.cpp	/^    auto good_hash_function = [](const int& key) {$/;"	f	function:C_benchmark_iterate	file:
__anona08f8fb80102	hashmap.cpp	/^    auto isNotNullptr = [ ](const auto& v){$/;"	f	function:HashMap::first_not_empty_bucket	file:
_bucket	hashmap_iterator.h	/^    size_t _bucket;$/;"	m	class:HashMapIterator	typeref:typename:size_t
_buckets_array	hashmap.h	/^    std::vector<node*> _buckets_array;$/;"	m	class:HashMap	typeref:typename:std::vector<node * >
_buckets_array	hashmap_iterator.h	/^    bucket_array_type* _buckets_array;$/;"	m	class:HashMapIterator	typeref:typename:bucket_array_type *
_hash_function	hashmap.h	/^    H _hash_function;$/;"	m	class:HashMap	typeref:typename:H
_node	hashmap_iterator.h	/^    node* _node;$/;"	m	class:HashMapIterator	typeref:typename:node *
_size	hashmap.h	/^    size_t _size;$/;"	m	class:HashMap	typeref:typename:size_t
at	hashmap.cpp	/^M& HashMap<K, M, H>::at(const K& key) const{$/;"	f	class:HashMap	typeref:typename:M &
begin	hashmap.cpp	/^typename HashMap<K, M, H>::const_iterator HashMap<K, M, H>::begin() const {$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::const_iterator
begin	hashmap.cpp	/^typename HashMap<K, M, H>::iterator HashMap<K, M, H>::begin() {$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::iterator
bucket_array_type	hashmap.h	/^    using bucket_array_type = decltype(_buckets_array);$/;"	t	class:HashMap
bucket_array_type	hashmap_iterator.h	/^    using bucket_array_type = typename Map::bucket_array_type;$/;"	t	class:HashMapIterator	typeref:typename:Map::bucket_array_type
bucket_count	hashmap.cpp	/^inline size_t HashMap<K, M, H>::bucket_count() const{$/;"	f	class:HashMap	typeref:typename:size_t
check_map_equal	tests.cpp	/^template <typename Map1, typename Map2> bool check_map_equal(Map1& map, Map2& answer) {$/;"	f	typeref:typename:bool
clear	hashmap.cpp	/^void HashMap<K, M, H>::clear() {$/;"	f	class:HashMap	typeref:typename:void
clock_type	tests.cpp	/^using clock_type = std::chrono::high_resolution_clock;$/;"	t	typeref:typename:std::chrono::high_resolution_clock	file:
const_iterator	hashmap.h	/^    using const_iterator = HashMapIterator<HashMap, true>;$/;"	t	class:HashMap	typeref:typename:HashMapIterator<HashMap,true>
contains	hashmap.cpp	/^bool HashMap<K, M, H>::contains(const K& key) const{$/;"	f	class:HashMap	typeref:typename:bool
debug	hashmap.cpp	/^    void HashMap<K, M, H>::debug() const {$/;"	f	class:HashMap	typeref:typename:void
difference_type	hashmap_iterator.h	/^    using difference_type   =   std::ptrdiff_t;$/;"	t	class:HashMapIterator	typeref:typename:std::ptrdiff_t
empty	hashmap.cpp	/^inline bool HashMap<K, M, H>::empty() const{$/;"	f	class:HashMap	typeref:typename:bool
end	hashmap.cpp	/^typename HashMap<K, M, H>::iterator HashMap<K, M, H>::end() {$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::iterator
ensure_at_return_is_const	tests.cpp	/^auto ensure_at_return_is_const(const T& map) -> decltype((void) (map.at(0) = 3), void()) {$/;"	f	typeref:typename:decltype((void)(map.at (0)=3),void ())
ensure_at_return_is_const	tests.cpp	/^void ensure_at_return_is_const(Ts...) {}$/;"	f	typeref:typename:void
ensure_no_const_index_op	tests.cpp	/^auto ensure_no_const_index_op(const T& map) -> decltype((void) (map[0]), void()) {$/;"	f	typeref:typename:decltype((void)(map[0]),void ())
ensure_no_const_index_op	tests.cpp	/^void ensure_no_const_index_op(Ts...) {}$/;"	f	typeref:typename:void
erase	hashmap.cpp	/^bool HashMap<K, M, H>::erase(const K& key) {$/;"	f	class:HashMap	typeref:typename:bool
erase	hashmap.cpp	/^typename HashMap<K, M, H>::iterator HashMap<K, M, H>::erase(typename HashMap<K, M, H>::const_ite/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::iterator
find	hashmap.cpp	/^typename HashMap<K, M, H>::iterator HashMap<K, M, H>::find(const K& key) const{$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::iterator
find_keys	main.cpp	/^std::set<KeyType> find_keys(const HashMap<KeyType, MappedTyped>& map){$/;"	f	typeref:typename:std::set<KeyType>
find_node	hashmap.cpp	/^typename HashMap<K, M, H>::node_pair HashMap<K, M, H>::find_node(const K& key) const {$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::node_pair
first_not_empty_bucket	hashmap.cpp	/^size_t HashMap<K, M, H>::first_not_empty_bucket() const {$/;"	f	class:HashMap	typeref:typename:size_t
init_map	main.cpp	/^void init_map(HashMap<string, int>& map) {$/;"	f	typeref:typename:void
insert	hashmap.cpp	/^std::pair<typename HashMap<K, M, H>::iterator, bool> HashMap<K, M, H>::insert(const value_type& /;"	f	class:HashMap	typeref:typename:std::pair<typename HashMap<K,M,H>::iterator,bool>
iterator	hashmap.h	/^    using iterator = HashMapIterator<HashMap, false>;$/;"	t	class:HashMap	typeref:typename:HashMapIterator<HashMap,false>
iterator_category	hashmap_iterator.h	/^    using iterator_category =   std::forward_iterator_tag;$/;"	t	class:HashMapIterator	typeref:typename:std::forward_iterator_tag
kDefaultBuckets	hashmap.h	/^    static const size_t kDefaultBuckets = 10;$/;"	m	class:HashMap	typeref:typename:const size_t
keys	tests.cpp	/^const std::vector<std::string> keys {"A", "B", "C", "Not found"};$/;"	v	typeref:typename:const std::vector<std::string>
line	tests.cpp	/^    int line;$/;"	m	struct:VerifyTrueAssertionFailure	typeref:typename:int	file:
load_factor	hashmap.cpp	/^inline float HashMap<K, M, H>::load_factor() const {$/;"	f	class:HashMap	typeref:typename:float
main	main.cpp	/^int main() {$/;"	f	typeref:typename:int
make_iterator	hashmap.cpp	/^typename HashMap<K, M, H>::iterator HashMap<K, M, H>::make_iterator(node* curr) {$/;"	f	class:HashMap	typeref:typename:HashMap<K,M,H>::iterator
next	hashmap.h	/^        node* next;$/;"	m	struct:HashMap::node	typeref:typename:node *
node	hashmap.h	/^        node(const value_type& value = value_type(), node* next = nullptr) :$/;"	f	struct:HashMap::node
node	hashmap.h	/^    struct node {$/;"	s	class:HashMap
node	hashmap_iterator.h	/^    using node = typename Map::node;$/;"	t	class:HashMapIterator	typeref:typename:Map::node
node_pair	hashmap.h	/^    using node_pair = std::pair<typename HashMap::node*, typename HashMap::node*>;$/;"	t	class:HashMap	typeref:typename:std::pair<typename HashMap::node *,typename HashMap::node * >
ns	tests.cpp	/^using ns = std::chrono::nanoseconds;$/;"	t	typeref:typename:std::chrono::nanoseconds	file:
operator !=	hashmap.cpp	/^bool operator!=(const HashMap<K, M, H>& lhs, const HashMap<K, M, H>& rhs) {$/;"	f	typeref:typename:bool
operator !=	hashmap_iterator.h	/^bool operator!=(const HashMapIterator<Map, IsConst>& lhs, const HashMapIterator<Map, IsConst>& r/;"	f	typeref:typename:bool
operator *	hashmap_iterator.h	/^typename HashMapIterator<Map, IsConst>::reference HashMapIterator<Map, IsConst>::operator*() con/;"	f	class:HashMapIterator	typeref:typename:HashMapIterator<Map,IsConst>::reference
operator ++	hashmap_iterator.h	/^HashMapIterator<Map, IsConst> HashMapIterator<Map, IsConst>::operator++(int) {$/;"	f	class:HashMapIterator	typeref:typename:HashMapIterator<Map,IsConst>
operator ++	hashmap_iterator.h	/^HashMapIterator<Map, IsConst>& HashMapIterator<Map, IsConst>::operator++() {$/;"	f	class:HashMapIterator	typeref:typename:HashMapIterator<Map,IsConst> &
operator ->	hashmap_iterator.h	/^typename HashMapIterator<Map, IsConst>::pointer HashMapIterator<Map, IsConst>::operator->() cons/;"	f	class:HashMapIterator	typeref:typename:HashMapIterator<Map,IsConst>::pointer
operator <<	hashmap.cpp	/^std::ostream& operator<<(std::ostream& os, const HashMap<K, M, H>& rhs) {$/;"	f	typeref:typename:std::ostream &
operator ==	hashmap.cpp	/^bool operator==(const HashMap<K, M, H>& lhs, const HashMap<K, M, H>& rhs) {$/;"	f	typeref:typename:bool
operator ==	hashmap_iterator.h	/^bool operator==(const HashMapIterator<Map, IsConst>& lhs, const HashMapIterator<Map, IsConst>& r/;"	f	typeref:typename:bool
operator HashMapIterator<Map,true>	hashmap_iterator.h	/^    operator HashMapIterator<Map, true>() const {$/;"	f	class:HashMapIterator
operator []	hashmap.cpp	/^M& HashMap<K, M, H>::operator[](const K& key) {$/;"	f	class:HashMap	typeref:typename:M &
pointer	hashmap_iterator.h	/^    using pointer           =   value_type*;$/;"	t	class:HashMapIterator	typeref:typename:value_type *
print_difference	main.cpp	/^void print_difference(const HashMap<string, int>& lecturer_record, const string lecturer1, const/;"	f	typeref:typename:void
print_with_commas	tests.cpp	/^std::string print_with_commas(long long int n)$/;"	f	typeref:typename:std::string
reference	hashmap_iterator.h	/^    using reference         =   value_type&;$/;"	t	class:HashMapIterator	typeref:typename:value_type &
rehash	hashmap.cpp	/^void HashMap<K, M, H>::rehash(size_t new_bucket_count) {$/;"	f	class:HashMap	typeref:typename:void
run_benchmark	tests.cpp	/^int run_benchmark() {$/;"	f	typeref:typename:int
run_milestone1_tests	tests.cpp	/^int run_milestone1_tests() {$/;"	f	typeref:typename:int
run_milestone2_tests	tests.cpp	/^int run_milestone2_tests() {$/;"	f	typeref:typename:int
run_milestone3_tests	tests.cpp	/^int run_milestone3_tests() {$/;"	f	typeref:typename:int
run_milestone4_tests	tests.cpp	/^int run_milestone4_tests() {$/;"	f	typeref:typename:int
run_test	tests.cpp	/^int run_test(const T& test, const string& test_name) {$/;"	f	typeref:typename:int
run_test_harness	tests.cpp	/^void run_test_harness() {$/;"	f	typeref:typename:void
size	hashmap.cpp	/^inline size_t HashMap<K, M, H>::size() const{$/;"	f	class:HashMap	typeref:typename:size_t
skip_test	tests.cpp	/^void skip_test(const string& test_name) {$/;"	f	typeref:typename:void
student_main	main.cpp	/^int student_main() {$/;"	f	typeref:typename:int
unused_rehash_correct_by_time	tests.cpp	/^__attribute__((unused)) void unused_rehash_correct_by_time() {$/;"	f	typeref:typename:void
value	hashmap.h	/^        value_type value;$/;"	m	struct:HashMap::node	typeref:typename:value_type
value_type	hashmap.h	/^    using value_type = std::pair<const K, M>;$/;"	t	class:HashMap	typeref:typename:std::pair<const K,M>
value_type	hashmap_iterator.h	/^    using value_type        =   std::conditional_t<IsConst, const typename Map::value_type, type/;"	t	class:HashMapIterator	typeref:typename:std::conditional_t<IsConst,const typename Map::value_type,typename Map::value_type>
vec	tests.cpp	/^const std::vector<std::pair<std::string, int> > vec {$/;"	v	typeref:typename:const std::vector<std::pair<std::string,int>>
~HashMap	hashmap.cpp	/^HashMap<K, M, H>::~HashMap() {$/;"	f	class:HashMap
